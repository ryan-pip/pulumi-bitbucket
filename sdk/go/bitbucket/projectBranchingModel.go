// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package bitbucket

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
	"github.com/ryan-pip/pulumi-bitbucket/sdk/go/bitbucket/internal"
)

type ProjectBranchingModel struct {
	pulumi.CustomResourceState

	BranchTypes ProjectBranchingModelBranchTypeArrayOutput `pulumi:"branchTypes"`
	Development ProjectBranchingModelDevelopmentOutput     `pulumi:"development"`
	Production  ProjectBranchingModelProductionPtrOutput   `pulumi:"production"`
	Project     pulumi.StringOutput                        `pulumi:"project"`
	Workspace   pulumi.StringOutput                        `pulumi:"workspace"`
}

// NewProjectBranchingModel registers a new resource with the given unique name, arguments, and options.
func NewProjectBranchingModel(ctx *pulumi.Context,
	name string, args *ProjectBranchingModelArgs, opts ...pulumi.ResourceOption) (*ProjectBranchingModel, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Development == nil {
		return nil, errors.New("invalid value for required argument 'Development'")
	}
	if args.Project == nil {
		return nil, errors.New("invalid value for required argument 'Project'")
	}
	if args.Workspace == nil {
		return nil, errors.New("invalid value for required argument 'Workspace'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ProjectBranchingModel
	err := ctx.RegisterResource("bitbucket:index/projectBranchingModel:ProjectBranchingModel", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetProjectBranchingModel gets an existing ProjectBranchingModel resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetProjectBranchingModel(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ProjectBranchingModelState, opts ...pulumi.ResourceOption) (*ProjectBranchingModel, error) {
	var resource ProjectBranchingModel
	err := ctx.ReadResource("bitbucket:index/projectBranchingModel:ProjectBranchingModel", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ProjectBranchingModel resources.
type projectBranchingModelState struct {
	BranchTypes []ProjectBranchingModelBranchType `pulumi:"branchTypes"`
	Development *ProjectBranchingModelDevelopment `pulumi:"development"`
	Production  *ProjectBranchingModelProduction  `pulumi:"production"`
	Project     *string                           `pulumi:"project"`
	Workspace   *string                           `pulumi:"workspace"`
}

type ProjectBranchingModelState struct {
	BranchTypes ProjectBranchingModelBranchTypeArrayInput
	Development ProjectBranchingModelDevelopmentPtrInput
	Production  ProjectBranchingModelProductionPtrInput
	Project     pulumi.StringPtrInput
	Workspace   pulumi.StringPtrInput
}

func (ProjectBranchingModelState) ElementType() reflect.Type {
	return reflect.TypeOf((*projectBranchingModelState)(nil)).Elem()
}

type projectBranchingModelArgs struct {
	BranchTypes []ProjectBranchingModelBranchType `pulumi:"branchTypes"`
	Development ProjectBranchingModelDevelopment  `pulumi:"development"`
	Production  *ProjectBranchingModelProduction  `pulumi:"production"`
	Project     string                            `pulumi:"project"`
	Workspace   string                            `pulumi:"workspace"`
}

// The set of arguments for constructing a ProjectBranchingModel resource.
type ProjectBranchingModelArgs struct {
	BranchTypes ProjectBranchingModelBranchTypeArrayInput
	Development ProjectBranchingModelDevelopmentInput
	Production  ProjectBranchingModelProductionPtrInput
	Project     pulumi.StringInput
	Workspace   pulumi.StringInput
}

func (ProjectBranchingModelArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*projectBranchingModelArgs)(nil)).Elem()
}

type ProjectBranchingModelInput interface {
	pulumi.Input

	ToProjectBranchingModelOutput() ProjectBranchingModelOutput
	ToProjectBranchingModelOutputWithContext(ctx context.Context) ProjectBranchingModelOutput
}

func (*ProjectBranchingModel) ElementType() reflect.Type {
	return reflect.TypeOf((**ProjectBranchingModel)(nil)).Elem()
}

func (i *ProjectBranchingModel) ToProjectBranchingModelOutput() ProjectBranchingModelOutput {
	return i.ToProjectBranchingModelOutputWithContext(context.Background())
}

func (i *ProjectBranchingModel) ToProjectBranchingModelOutputWithContext(ctx context.Context) ProjectBranchingModelOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProjectBranchingModelOutput)
}

func (i *ProjectBranchingModel) ToOutput(ctx context.Context) pulumix.Output[*ProjectBranchingModel] {
	return pulumix.Output[*ProjectBranchingModel]{
		OutputState: i.ToProjectBranchingModelOutputWithContext(ctx).OutputState,
	}
}

// ProjectBranchingModelArrayInput is an input type that accepts ProjectBranchingModelArray and ProjectBranchingModelArrayOutput values.
// You can construct a concrete instance of `ProjectBranchingModelArrayInput` via:
//
//	ProjectBranchingModelArray{ ProjectBranchingModelArgs{...} }
type ProjectBranchingModelArrayInput interface {
	pulumi.Input

	ToProjectBranchingModelArrayOutput() ProjectBranchingModelArrayOutput
	ToProjectBranchingModelArrayOutputWithContext(context.Context) ProjectBranchingModelArrayOutput
}

type ProjectBranchingModelArray []ProjectBranchingModelInput

func (ProjectBranchingModelArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ProjectBranchingModel)(nil)).Elem()
}

func (i ProjectBranchingModelArray) ToProjectBranchingModelArrayOutput() ProjectBranchingModelArrayOutput {
	return i.ToProjectBranchingModelArrayOutputWithContext(context.Background())
}

func (i ProjectBranchingModelArray) ToProjectBranchingModelArrayOutputWithContext(ctx context.Context) ProjectBranchingModelArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProjectBranchingModelArrayOutput)
}

func (i ProjectBranchingModelArray) ToOutput(ctx context.Context) pulumix.Output[[]*ProjectBranchingModel] {
	return pulumix.Output[[]*ProjectBranchingModel]{
		OutputState: i.ToProjectBranchingModelArrayOutputWithContext(ctx).OutputState,
	}
}

// ProjectBranchingModelMapInput is an input type that accepts ProjectBranchingModelMap and ProjectBranchingModelMapOutput values.
// You can construct a concrete instance of `ProjectBranchingModelMapInput` via:
//
//	ProjectBranchingModelMap{ "key": ProjectBranchingModelArgs{...} }
type ProjectBranchingModelMapInput interface {
	pulumi.Input

	ToProjectBranchingModelMapOutput() ProjectBranchingModelMapOutput
	ToProjectBranchingModelMapOutputWithContext(context.Context) ProjectBranchingModelMapOutput
}

type ProjectBranchingModelMap map[string]ProjectBranchingModelInput

func (ProjectBranchingModelMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ProjectBranchingModel)(nil)).Elem()
}

func (i ProjectBranchingModelMap) ToProjectBranchingModelMapOutput() ProjectBranchingModelMapOutput {
	return i.ToProjectBranchingModelMapOutputWithContext(context.Background())
}

func (i ProjectBranchingModelMap) ToProjectBranchingModelMapOutputWithContext(ctx context.Context) ProjectBranchingModelMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProjectBranchingModelMapOutput)
}

func (i ProjectBranchingModelMap) ToOutput(ctx context.Context) pulumix.Output[map[string]*ProjectBranchingModel] {
	return pulumix.Output[map[string]*ProjectBranchingModel]{
		OutputState: i.ToProjectBranchingModelMapOutputWithContext(ctx).OutputState,
	}
}

type ProjectBranchingModelOutput struct{ *pulumi.OutputState }

func (ProjectBranchingModelOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ProjectBranchingModel)(nil)).Elem()
}

func (o ProjectBranchingModelOutput) ToProjectBranchingModelOutput() ProjectBranchingModelOutput {
	return o
}

func (o ProjectBranchingModelOutput) ToProjectBranchingModelOutputWithContext(ctx context.Context) ProjectBranchingModelOutput {
	return o
}

func (o ProjectBranchingModelOutput) ToOutput(ctx context.Context) pulumix.Output[*ProjectBranchingModel] {
	return pulumix.Output[*ProjectBranchingModel]{
		OutputState: o.OutputState,
	}
}

func (o ProjectBranchingModelOutput) BranchTypes() ProjectBranchingModelBranchTypeArrayOutput {
	return o.ApplyT(func(v *ProjectBranchingModel) ProjectBranchingModelBranchTypeArrayOutput { return v.BranchTypes }).(ProjectBranchingModelBranchTypeArrayOutput)
}

func (o ProjectBranchingModelOutput) Development() ProjectBranchingModelDevelopmentOutput {
	return o.ApplyT(func(v *ProjectBranchingModel) ProjectBranchingModelDevelopmentOutput { return v.Development }).(ProjectBranchingModelDevelopmentOutput)
}

func (o ProjectBranchingModelOutput) Production() ProjectBranchingModelProductionPtrOutput {
	return o.ApplyT(func(v *ProjectBranchingModel) ProjectBranchingModelProductionPtrOutput { return v.Production }).(ProjectBranchingModelProductionPtrOutput)
}

func (o ProjectBranchingModelOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *ProjectBranchingModel) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

func (o ProjectBranchingModelOutput) Workspace() pulumi.StringOutput {
	return o.ApplyT(func(v *ProjectBranchingModel) pulumi.StringOutput { return v.Workspace }).(pulumi.StringOutput)
}

type ProjectBranchingModelArrayOutput struct{ *pulumi.OutputState }

func (ProjectBranchingModelArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ProjectBranchingModel)(nil)).Elem()
}

func (o ProjectBranchingModelArrayOutput) ToProjectBranchingModelArrayOutput() ProjectBranchingModelArrayOutput {
	return o
}

func (o ProjectBranchingModelArrayOutput) ToProjectBranchingModelArrayOutputWithContext(ctx context.Context) ProjectBranchingModelArrayOutput {
	return o
}

func (o ProjectBranchingModelArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]*ProjectBranchingModel] {
	return pulumix.Output[[]*ProjectBranchingModel]{
		OutputState: o.OutputState,
	}
}

func (o ProjectBranchingModelArrayOutput) Index(i pulumi.IntInput) ProjectBranchingModelOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ProjectBranchingModel {
		return vs[0].([]*ProjectBranchingModel)[vs[1].(int)]
	}).(ProjectBranchingModelOutput)
}

type ProjectBranchingModelMapOutput struct{ *pulumi.OutputState }

func (ProjectBranchingModelMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ProjectBranchingModel)(nil)).Elem()
}

func (o ProjectBranchingModelMapOutput) ToProjectBranchingModelMapOutput() ProjectBranchingModelMapOutput {
	return o
}

func (o ProjectBranchingModelMapOutput) ToProjectBranchingModelMapOutputWithContext(ctx context.Context) ProjectBranchingModelMapOutput {
	return o
}

func (o ProjectBranchingModelMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]*ProjectBranchingModel] {
	return pulumix.Output[map[string]*ProjectBranchingModel]{
		OutputState: o.OutputState,
	}
}

func (o ProjectBranchingModelMapOutput) MapIndex(k pulumi.StringInput) ProjectBranchingModelOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ProjectBranchingModel {
		return vs[0].(map[string]*ProjectBranchingModel)[vs[1].(string)]
	}).(ProjectBranchingModelOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ProjectBranchingModelInput)(nil)).Elem(), &ProjectBranchingModel{})
	pulumi.RegisterInputType(reflect.TypeOf((*ProjectBranchingModelArrayInput)(nil)).Elem(), ProjectBranchingModelArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ProjectBranchingModelMapInput)(nil)).Elem(), ProjectBranchingModelMap{})
	pulumi.RegisterOutputType(ProjectBranchingModelOutput{})
	pulumi.RegisterOutputType(ProjectBranchingModelArrayOutput{})
	pulumi.RegisterOutputType(ProjectBranchingModelMapOutput{})
}
