// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package bitbucket

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/ryan-pip/pulumi-bitbucket/sdk/go/bitbucket/internal"
)

// Provides a Bitbucket branching model resource.
//
// This allows you for setting up branching models for your repository.
//
// OAuth2 Scopes: `repository:admin`
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/ryan-pip/pulumi-bitbucket/sdk/go/bitbucket"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// Manage your repositories branching models
//			testRepository, err := bitbucket.NewRepository(ctx, "testRepository", &bitbucket.RepositoryArgs{
//				Owner: pulumi.String("example"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = bitbucket.NewBranchingModel(ctx, "testBranchingModel", &bitbucket.BranchingModelArgs{
//				Owner:      pulumi.String("example"),
//				Repository: testRepository.Name,
//				Development: &bitbucket.BranchingModelDevelopmentArgs{
//					UseMainbranch: pulumi.Bool(true),
//				},
//				BranchTypes: bitbucket.BranchingModelBranchTypeArray{
//					&bitbucket.BranchingModelBranchTypeArgs{
//						Enabled: pulumi.Bool(true),
//						Kind:    pulumi.String("feature"),
//						Prefix:  pulumi.String("test/"),
//					},
//					&bitbucket.BranchingModelBranchTypeArgs{
//						Enabled: pulumi.Bool(true),
//						Kind:    pulumi.String("hotfix"),
//						Prefix:  pulumi.String("hotfix/"),
//					},
//					&bitbucket.BranchingModelBranchTypeArgs{
//						Enabled: pulumi.Bool(true),
//						Kind:    pulumi.String("release"),
//						Prefix:  pulumi.String("release/"),
//					},
//					&bitbucket.BranchingModelBranchTypeArgs{
//						Enabled: pulumi.Bool(true),
//						Kind:    pulumi.String("bugfix"),
//						Prefix:  pulumi.String("bugfix/"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Branching Models can be imported using the owner and repo separated by a (`/`), e.g.,
//
// ```sh
//
//	$ pulumi import bitbucket:index/branchingModel:BranchingModel example owner/repo
//
// ```
type BranchingModel struct {
	pulumi.CustomResourceState

	// A set of branch type to define `feature`, `bugfix`, `release`, `hotfix` prefixes. See Branch Type below.
	BranchTypes BranchingModelBranchTypeArrayOutput `pulumi:"branchTypes"`
	// The development branch can be configured to a specific branch or to track the main branch. When set to a specific branch it must currently exist. Only the passed properties will be updated. The properties not passed will be left unchanged. A request without a development property will leave the development branch unchanged. See Development below.
	Development BranchingModelDevelopmentOutput `pulumi:"development"`
	// The owner of this repository. Can be you or any team you
	// have write access to.
	Owner pulumi.StringOutput `pulumi:"owner"`
	// The production branch can be a specific branch, the main branch or disabled. When set to a specific branch it must currently exist. The enabled property can be used to enable (true) or disable (false) it. Only the passed properties will be updated. The properties not passed will be left unchanged. A request without a production property will leave the production branch unchanged. See Production below.
	Production BranchingModelProductionPtrOutput `pulumi:"production"`
	// The name of the repository.
	Repository pulumi.StringOutput `pulumi:"repository"`
}

// NewBranchingModel registers a new resource with the given unique name, arguments, and options.
func NewBranchingModel(ctx *pulumi.Context,
	name string, args *BranchingModelArgs, opts ...pulumi.ResourceOption) (*BranchingModel, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Development == nil {
		return nil, errors.New("invalid value for required argument 'Development'")
	}
	if args.Owner == nil {
		return nil, errors.New("invalid value for required argument 'Owner'")
	}
	if args.Repository == nil {
		return nil, errors.New("invalid value for required argument 'Repository'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource BranchingModel
	err := ctx.RegisterResource("bitbucket:index/branchingModel:BranchingModel", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetBranchingModel gets an existing BranchingModel resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetBranchingModel(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *BranchingModelState, opts ...pulumi.ResourceOption) (*BranchingModel, error) {
	var resource BranchingModel
	err := ctx.ReadResource("bitbucket:index/branchingModel:BranchingModel", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering BranchingModel resources.
type branchingModelState struct {
	// A set of branch type to define `feature`, `bugfix`, `release`, `hotfix` prefixes. See Branch Type below.
	BranchTypes []BranchingModelBranchType `pulumi:"branchTypes"`
	// The development branch can be configured to a specific branch or to track the main branch. When set to a specific branch it must currently exist. Only the passed properties will be updated. The properties not passed will be left unchanged. A request without a development property will leave the development branch unchanged. See Development below.
	Development *BranchingModelDevelopment `pulumi:"development"`
	// The owner of this repository. Can be you or any team you
	// have write access to.
	Owner *string `pulumi:"owner"`
	// The production branch can be a specific branch, the main branch or disabled. When set to a specific branch it must currently exist. The enabled property can be used to enable (true) or disable (false) it. Only the passed properties will be updated. The properties not passed will be left unchanged. A request without a production property will leave the production branch unchanged. See Production below.
	Production *BranchingModelProduction `pulumi:"production"`
	// The name of the repository.
	Repository *string `pulumi:"repository"`
}

type BranchingModelState struct {
	// A set of branch type to define `feature`, `bugfix`, `release`, `hotfix` prefixes. See Branch Type below.
	BranchTypes BranchingModelBranchTypeArrayInput
	// The development branch can be configured to a specific branch or to track the main branch. When set to a specific branch it must currently exist. Only the passed properties will be updated. The properties not passed will be left unchanged. A request without a development property will leave the development branch unchanged. See Development below.
	Development BranchingModelDevelopmentPtrInput
	// The owner of this repository. Can be you or any team you
	// have write access to.
	Owner pulumi.StringPtrInput
	// The production branch can be a specific branch, the main branch or disabled. When set to a specific branch it must currently exist. The enabled property can be used to enable (true) or disable (false) it. Only the passed properties will be updated. The properties not passed will be left unchanged. A request without a production property will leave the production branch unchanged. See Production below.
	Production BranchingModelProductionPtrInput
	// The name of the repository.
	Repository pulumi.StringPtrInput
}

func (BranchingModelState) ElementType() reflect.Type {
	return reflect.TypeOf((*branchingModelState)(nil)).Elem()
}

type branchingModelArgs struct {
	// A set of branch type to define `feature`, `bugfix`, `release`, `hotfix` prefixes. See Branch Type below.
	BranchTypes []BranchingModelBranchType `pulumi:"branchTypes"`
	// The development branch can be configured to a specific branch or to track the main branch. When set to a specific branch it must currently exist. Only the passed properties will be updated. The properties not passed will be left unchanged. A request without a development property will leave the development branch unchanged. See Development below.
	Development BranchingModelDevelopment `pulumi:"development"`
	// The owner of this repository. Can be you or any team you
	// have write access to.
	Owner string `pulumi:"owner"`
	// The production branch can be a specific branch, the main branch or disabled. When set to a specific branch it must currently exist. The enabled property can be used to enable (true) or disable (false) it. Only the passed properties will be updated. The properties not passed will be left unchanged. A request without a production property will leave the production branch unchanged. See Production below.
	Production *BranchingModelProduction `pulumi:"production"`
	// The name of the repository.
	Repository string `pulumi:"repository"`
}

// The set of arguments for constructing a BranchingModel resource.
type BranchingModelArgs struct {
	// A set of branch type to define `feature`, `bugfix`, `release`, `hotfix` prefixes. See Branch Type below.
	BranchTypes BranchingModelBranchTypeArrayInput
	// The development branch can be configured to a specific branch or to track the main branch. When set to a specific branch it must currently exist. Only the passed properties will be updated. The properties not passed will be left unchanged. A request without a development property will leave the development branch unchanged. See Development below.
	Development BranchingModelDevelopmentInput
	// The owner of this repository. Can be you or any team you
	// have write access to.
	Owner pulumi.StringInput
	// The production branch can be a specific branch, the main branch or disabled. When set to a specific branch it must currently exist. The enabled property can be used to enable (true) or disable (false) it. Only the passed properties will be updated. The properties not passed will be left unchanged. A request without a production property will leave the production branch unchanged. See Production below.
	Production BranchingModelProductionPtrInput
	// The name of the repository.
	Repository pulumi.StringInput
}

func (BranchingModelArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*branchingModelArgs)(nil)).Elem()
}

type BranchingModelInput interface {
	pulumi.Input

	ToBranchingModelOutput() BranchingModelOutput
	ToBranchingModelOutputWithContext(ctx context.Context) BranchingModelOutput
}

func (*BranchingModel) ElementType() reflect.Type {
	return reflect.TypeOf((**BranchingModel)(nil)).Elem()
}

func (i *BranchingModel) ToBranchingModelOutput() BranchingModelOutput {
	return i.ToBranchingModelOutputWithContext(context.Background())
}

func (i *BranchingModel) ToBranchingModelOutputWithContext(ctx context.Context) BranchingModelOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BranchingModelOutput)
}

// BranchingModelArrayInput is an input type that accepts BranchingModelArray and BranchingModelArrayOutput values.
// You can construct a concrete instance of `BranchingModelArrayInput` via:
//
//	BranchingModelArray{ BranchingModelArgs{...} }
type BranchingModelArrayInput interface {
	pulumi.Input

	ToBranchingModelArrayOutput() BranchingModelArrayOutput
	ToBranchingModelArrayOutputWithContext(context.Context) BranchingModelArrayOutput
}

type BranchingModelArray []BranchingModelInput

func (BranchingModelArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*BranchingModel)(nil)).Elem()
}

func (i BranchingModelArray) ToBranchingModelArrayOutput() BranchingModelArrayOutput {
	return i.ToBranchingModelArrayOutputWithContext(context.Background())
}

func (i BranchingModelArray) ToBranchingModelArrayOutputWithContext(ctx context.Context) BranchingModelArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BranchingModelArrayOutput)
}

// BranchingModelMapInput is an input type that accepts BranchingModelMap and BranchingModelMapOutput values.
// You can construct a concrete instance of `BranchingModelMapInput` via:
//
//	BranchingModelMap{ "key": BranchingModelArgs{...} }
type BranchingModelMapInput interface {
	pulumi.Input

	ToBranchingModelMapOutput() BranchingModelMapOutput
	ToBranchingModelMapOutputWithContext(context.Context) BranchingModelMapOutput
}

type BranchingModelMap map[string]BranchingModelInput

func (BranchingModelMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*BranchingModel)(nil)).Elem()
}

func (i BranchingModelMap) ToBranchingModelMapOutput() BranchingModelMapOutput {
	return i.ToBranchingModelMapOutputWithContext(context.Background())
}

func (i BranchingModelMap) ToBranchingModelMapOutputWithContext(ctx context.Context) BranchingModelMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BranchingModelMapOutput)
}

type BranchingModelOutput struct{ *pulumi.OutputState }

func (BranchingModelOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BranchingModel)(nil)).Elem()
}

func (o BranchingModelOutput) ToBranchingModelOutput() BranchingModelOutput {
	return o
}

func (o BranchingModelOutput) ToBranchingModelOutputWithContext(ctx context.Context) BranchingModelOutput {
	return o
}

// A set of branch type to define `feature`, `bugfix`, `release`, `hotfix` prefixes. See Branch Type below.
func (o BranchingModelOutput) BranchTypes() BranchingModelBranchTypeArrayOutput {
	return o.ApplyT(func(v *BranchingModel) BranchingModelBranchTypeArrayOutput { return v.BranchTypes }).(BranchingModelBranchTypeArrayOutput)
}

// The development branch can be configured to a specific branch or to track the main branch. When set to a specific branch it must currently exist. Only the passed properties will be updated. The properties not passed will be left unchanged. A request without a development property will leave the development branch unchanged. See Development below.
func (o BranchingModelOutput) Development() BranchingModelDevelopmentOutput {
	return o.ApplyT(func(v *BranchingModel) BranchingModelDevelopmentOutput { return v.Development }).(BranchingModelDevelopmentOutput)
}

// The owner of this repository. Can be you or any team you
// have write access to.
func (o BranchingModelOutput) Owner() pulumi.StringOutput {
	return o.ApplyT(func(v *BranchingModel) pulumi.StringOutput { return v.Owner }).(pulumi.StringOutput)
}

// The production branch can be a specific branch, the main branch or disabled. When set to a specific branch it must currently exist. The enabled property can be used to enable (true) or disable (false) it. Only the passed properties will be updated. The properties not passed will be left unchanged. A request without a production property will leave the production branch unchanged. See Production below.
func (o BranchingModelOutput) Production() BranchingModelProductionPtrOutput {
	return o.ApplyT(func(v *BranchingModel) BranchingModelProductionPtrOutput { return v.Production }).(BranchingModelProductionPtrOutput)
}

// The name of the repository.
func (o BranchingModelOutput) Repository() pulumi.StringOutput {
	return o.ApplyT(func(v *BranchingModel) pulumi.StringOutput { return v.Repository }).(pulumi.StringOutput)
}

type BranchingModelArrayOutput struct{ *pulumi.OutputState }

func (BranchingModelArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*BranchingModel)(nil)).Elem()
}

func (o BranchingModelArrayOutput) ToBranchingModelArrayOutput() BranchingModelArrayOutput {
	return o
}

func (o BranchingModelArrayOutput) ToBranchingModelArrayOutputWithContext(ctx context.Context) BranchingModelArrayOutput {
	return o
}

func (o BranchingModelArrayOutput) Index(i pulumi.IntInput) BranchingModelOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *BranchingModel {
		return vs[0].([]*BranchingModel)[vs[1].(int)]
	}).(BranchingModelOutput)
}

type BranchingModelMapOutput struct{ *pulumi.OutputState }

func (BranchingModelMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*BranchingModel)(nil)).Elem()
}

func (o BranchingModelMapOutput) ToBranchingModelMapOutput() BranchingModelMapOutput {
	return o
}

func (o BranchingModelMapOutput) ToBranchingModelMapOutputWithContext(ctx context.Context) BranchingModelMapOutput {
	return o
}

func (o BranchingModelMapOutput) MapIndex(k pulumi.StringInput) BranchingModelOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *BranchingModel {
		return vs[0].(map[string]*BranchingModel)[vs[1].(string)]
	}).(BranchingModelOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*BranchingModelInput)(nil)).Elem(), &BranchingModel{})
	pulumi.RegisterInputType(reflect.TypeOf((*BranchingModelArrayInput)(nil)).Elem(), BranchingModelArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*BranchingModelMapInput)(nil)).Elem(), BranchingModelMap{})
	pulumi.RegisterOutputType(BranchingModelOutput{})
	pulumi.RegisterOutputType(BranchingModelArrayOutput{})
	pulumi.RegisterOutputType(BranchingModelMapOutput{})
}
